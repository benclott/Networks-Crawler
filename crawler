#!/usr/bin/env python3

import argparse
import socket
import ssl
from html.parser import HTMLParser
import time
import sys

DEFAULT_SERVER = "proj5.3700.network"
DEFAULT_PORT = 443

class Crawler:
    def __init__(self, args):
        self.server = args.server
        self.port = args.port
        self.username = args.username
        self.password = args.password

    paths_checked = []

    def run(self):
        count = 0 # Counts how many requests we have set
        data = ''  # Store the data of the most recent recieved message
        mysocket = self.sockInit() 
        mysocket.connect((self.server, self.port))
        while(count <= 2):
            path = ""

            # #Send the first request to the server
            # if count == 0:
            #     path = self.getNextPath(data)#new path 
            #     request = self.createHTML(path[0])
            #     self.paths_checked.append(path[0])
            #     count = count + 1
            
            # #A message has already been recieved so use feedback information to craft next request
            # else:
            #     path = self.getNextPath(data) # Retrive the new path to send request to. 
            #     if path[0] == "200": # Ignore for now
            #         request = path[1]
            #     else:
            #         request = self.createHTML(path[0]) # Converts the path to the correct request format
            #         self.paths_checked.append(path[0]) # Mark the path as seen
            #         count = count + 1
            # #data = self.receive_message(mysocket)
            # #print("Response:\n%s" % data.decode('ascii'))

            path = self.getNextPath(data) # Gets the next path to check
            request = self.createHTML(path[0]) # Converts the path to the correct request format
            self.paths_checked.append(path[0]) # Mark the path as seen so it does not get checked again
            count = count + 1

            print("REQUEST SENT: ", request)
            mysocket.send(request.encode('ascii'))
            data = mysocket.recv(1000000).decode('ascii')
            #print("RRESPONSE RECIEVED: ", data)
            

    '''
        Create and preps the socket with ssl.
        Returns the socket object.
    '''
    def sockInit(self):
        mysocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        ssl_context = ssl.create_default_context()
        mysocket = ssl_context.wrap_socket(mysocket, server_hostname=self.server)
        return mysocket

    #Received the message and deals with exterior crap
    def receive_message(self, sock):
        
        response = "" # Empty buffer
        while(True):
            try:
                data = sock.recv(4096)
            except sock.TimeoutError:
                break     
            if(data == b'\n'): # We are at the end of the json
                break
            
            if(data == b''): # We are at the end of anything to be read
                break
            response += data.decode('ascii')
        return response

    '''
    Method to handle the response of the server
    This is where we initialize and call the html library we have created
    Should be looped through in the run and all the magic of html understanding happens here
    will create the path to send the next request and then also the message
    '''
    def getNextPath(self, data):
        root = "/fakebook/"
        if data == '': # first run through this will be empty as nothing has been recieved
            return [root, 0]

        brokenData = data.split("\n") # Split the response into lines
        response_code = int(brokenData[0].split(' ')[1]) # Extract response code from line 1
        if response_code == 302: # Server returned redirected PATH
            redirectedPath = brokenData[4].split(" ")[1].strip() # Extract the path from the response
            return [redirectedPath, 0] # Return path that the server redirects us to
        elif response_code == 200:
            # Split the response into header and body parts
            header_end_index = data.find('\r\n\r\n')
            header = data[:header_end_index]
            html = data[header_end_index + 4:].strip()

            print(html)
            parser = customHTML()
            parser.feed(html)  # Call feed method to start parsing
            return [200, 0]
        
        elif str(response_code).startswith('4'):
            print("You SUCK!!\n\n")
            sys.exit(0)


    #Method to decide which server/host to send the website too
    def sendto(self):
        ##Check if args.s exissts
        s = args.server
        p = args.port
        if s == "proj5.3700.network" and p == 443:
            #The default has been provided so...
            return ("www.3700.network", 443)
        else:
            return (s, p)

    def createHTML(self, path):
        httptype = "HTTP/1.1"
        #request = f'GET {} {}\r\nHost: {}:{}\r\nAccept-Encoding: identity\r\n\r\n'.format(path, httptype, self.server, self.port)
        request = 'GET {} HTTP/1.1\r\nHost: {}:{}\r\n\r\n'.format(path, self.server, self.port)
        return request


'''Create a custom HTML class that will identify and handle each problem'''
class customHTML(HTMLParser):
    uncrawled = []

    '''
    Look for start tags

    Figure out the start tag and then call the necessary next function
    will have base case for if everything is empty 
    '''
    def handle_starttag(self, tag, attrs):
        print("Encountered a start tag:", tag)


    '''
    We have reached the end of the tag so move on somehow and then recall handleState
    '''
    def handle_endtag(self, tag):
        print("Encountered an end tag :", tag)

    '''
    To be called inside the state tag
    Based on which function mpping it should do something 
    '''
    def handle_data(self, data):
        print("Encountered some data  :", data)

    
    '''
    Method to build a post request with the provided dat from class
    1. Take in all day
    2. Create a string of all necessary tags 

    The idea is that this will send a post, then we will skip the sending of a get
    After that we will read and start over

    Should return a path to a post message
    '''
    def sendPost(self):
        pass


    ##Send 
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='crawl Fakebook')
    parser.add_argument('-s', dest="server", type=str, default=DEFAULT_SERVER, help="The server to crawl")
    parser.add_argument('-p', dest="port", type=int, default=DEFAULT_PORT, help="The port to use")
    parser.add_argument('username', type=str, help="The username to use")
    parser.add_argument('password', type=str, help="The password to use")
    args = parser.parse_args()
    sender = Crawler(args)
    sender.run()


